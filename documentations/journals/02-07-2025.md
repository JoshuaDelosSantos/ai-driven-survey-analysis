# Journal Entry - 2 July 2025

**Focus:** Black-box Testing Analysis & Query Logic Issue Resolution Plan

## **Testing Summary: Critical Query Logic Issue Identified**

### **Issue Discovery Through Black-box Testing**
* Conducted comprehensive black-box testing of the RAG terminal application
* Identified a critical query logic flaw affecting user feedback queries about learning content
* **Root Cause**: LLM generating incorrect SQL joins between wrong tables

---

## **Problem Analysis**

### **The Query Logic Error**

**User Query**: "What feedback did users give about 'Live Learning' type learning contents?"

**Incorrect SQL Generated by LLM**:
```sql
SELECT
  ruf.comment AS user_comment,
  ruf.rating AS user_rating,
  lc.name AS learning_content_name
FROM rag_user_feedback AS ruf
JOIN learning_content AS lc
  ON ruf.query_text LIKE '%' || lc.name || '%'
WHERE
  lc.content_type = 'Live Learning'
```

**Why This is Wrong**:
- `rag_user_feedback` contains feedback about **RAG system performance** (queries like "How many users completed training?")
- `learning_content` contains course information
- **No semantic relationship** exists between RAG system queries and learning content names
- Results in 0 rows returned â†’ Answer synthesis failure

**Correct SQL Should Be**:
```sql
SELECT
  e.general_feedback,
  e.did_experience_issue_detail,
  e.course_application_other,
  lc.name AS learning_content_name,
  e.positive_learning_experience,
  e.effective_use_of_time,
  e.relevant_to_work
FROM evaluation e
JOIN learning_content lc ON e.learning_content_surrogate_key = lc.surrogate_key
WHERE lc.content_type = 'Live Learning'
  AND (e.general_feedback IS NOT NULL 
       OR e.did_experience_issue_detail IS NOT NULL 
       OR e.course_application_other IS NOT NULL)
```

### **Data Model Confusion**
The LLM lacks clear understanding of:
- **`rag_user_feedback`**: Feedback about the RAG system itself (meta-feedback)
- **`evaluation`**: Feedback about learning content and courses (actual content feedback)

---

## **Implementation Plan: Enhanced Schema Context System**

### **Phase 1: Immediate Fix - Enhanced Schema Descriptions**

#### **1.1 Update Schema Manager Context Generation**
**File**: `src/rag/core/text_to_sql/schema_manager.py`

**Objective**: Provide clearer table purpose descriptions to the LLM

**Implementation**:
```python
def _get_enhanced_table_descriptions(self) -> Dict[str, str]:
    """
    Enhanced table descriptions with clear purpose and usage context.
    """
    return {
        "users": "Contains user demographic information (user_level, agency). Use for demographic analysis and user categorization.",
        
        "learning_content": "Contains learning course/content metadata (name, content_type, target_level). Use for content analysis and categorization.",
        
        "attendance": "Contains user enrollment and completion records. Use for attendance statistics, completion rates, and participation analysis.",
        
        "evaluation": "Contains POST-COURSE EVALUATION RESPONSES from users about their learning experience. Use for USER FEEDBACK about learning content, satisfaction ratings, and course quality assessment. Contains free-text fields: general_feedback, did_experience_issue_detail, course_application_other.",
        
        "rag_embeddings": "Contains vector embeddings of evaluation free-text responses for semantic search. Internal system table for vector operations.",
        
        "rag_user_feedback": "Contains FEEDBACK ABOUT THIS RAG SYSTEM ITSELF (not about learning content). Users rate the quality of RAG system responses. Do NOT use for learning content feedback queries."
    }
```

#### **1.2 Enhanced Relationship Documentation**
```python
def _get_table_relationships_context(self) -> str:
    """
    Provide clear relationship context for SQL generation.
    """
    return """
    KEY TABLE RELATIONSHIPS:
    
    FOR LEARNING CONTENT FEEDBACK QUERIES:
    - evaluation â†’ learning_content (via learning_content_surrogate_key)
    - evaluation contains actual user feedback about courses/content
    - Use evaluation.general_feedback, evaluation.did_experience_issue_detail, evaluation.course_application_other
    
    FOR RAG SYSTEM PERFORMANCE QUERIES:
    - rag_user_feedback contains feedback about this AI system's responses
    - Do NOT use rag_user_feedback for learning content questions
    
    FOR ATTENDANCE/PARTICIPATION QUERIES:
    - attendance â†’ users (via user_id)
    - attendance â†’ learning_content (via learning_content_surrogate_key)
    """
```

### **Phase 2: Query Classification Enhancement - COMPLETED** âœ…

#### **2.1 Table-Specific Classification Patterns** âœ…
**File**: `src/rag/core/routing/aps_patterns.py`

**Status**: IMPLEMENTED AND TESTED
- âœ… Added `FeedbackTableClassifier` class with comprehensive patterns
- âœ… Content feedback patterns: 20 regex patterns to identify course/training feedback
- âœ… System feedback patterns: 11 regex patterns to identify RAG system feedback
- âœ… Pattern matching validated: Original problematic query correctly identifies `evaluation` table

**Key Enhancement**: Added patterns that specifically route feedback queries correctly

```python
# Examples of implemented patterns
content_feedback_patterns = [
    # Catches the original problem query
    r'\b(?:what|how).*(?:feedback|comments|evaluation|review|rating).*(?:users?|participants?|attendees?|students?).*(?:give|gave|provide|provided).*(?:about|regarding|for|on).*(?:course|training|learning|content)\b',
    # ... 19 more patterns
]

system_feedback_patterns = [
    r'\b(?:feedback|comments|evaluation|review|rating).*(?:about|regarding|for|on).*(?:system|platform|interface|search|query|response|answer|ai|rag)\b',
    # ... 10 more patterns
]
```

**Test Results**:
- âœ… Original query: "What feedback did users give about 'Live Learning' type learning contents?" â†’ `content` type, `evaluation` table (confidence: 0.70)
- âœ… System query: "What feedback exists about search quality?" â†’ `system` type, `rag_user_feedback` table (confidence: 0.70)

#### **2.2 Enhanced SQL Generation Prompts** âœ…
**File**: `src/rag/core/text_to_sql/sql_tool.py`

**Status**: IMPLEMENTED
- âœ… Enhanced `generate_sql()` method to accept classification result
- âœ… Added `_create_feedback_table_guidance()` method for specific table recommendations
- âœ… Updated SQL generation prompt with critical feedback table guidance

**Enhancement**: Added specific guidance for feedback queries

```python
# Added to SQL generation prompt
CRITICAL FEEDBACK TABLE GUIDANCE (Phase 2 Enhancement)
When handling feedback queries, distinguish between:
- CONTENT FEEDBACK: Course/training feedback â†’ Use 'evaluation' table
- SYSTEM FEEDBACK: RAG system feedback â†’ Use 'rag_user_feedback' table

NEVER join 'rag_user_feedback' with 'learning_content' - these are separate domains.
```

#### **2.3 Enhanced Query Classifier Integration** âœ…
**Files**: 
- `src/rag/core/routing/query_classifier.py`
- `src/rag/core/routing/pattern_matcher.py`
- `src/rag/core/routing/llm_classifier.py`
- `src/rag/core/routing/data_structures.py`

**Status**: IMPLEMENTED
- âœ… Enhanced `ClassificationResult` with feedback table metadata
- âœ… Pattern matcher integration with feedback table classifier
- âœ… LLM classifier enhanced with table-specific context
- âœ… Table guidance appears in classification reasoning

**Key Enhancements**:
```python
# Added to ClassificationResult
feedback_table_suggestion: Optional[str] = None
feedback_confidence: Optional[float] = None

# Pattern matcher now includes table guidance in reasoning
reasoning = reasoning + f" [Table guidance: Use {feedback_classification['recommended_table']} table for {feedback_classification['table_type']} feedback]"
```

#### **2.4 Testing and Validation** âœ…
**File**: `test_phase2_classification.py`

**Status**: COMPLETED
- âœ… Comprehensive test suite for feedback table classifier
- âœ… Integration tests with enhanced query classifier
- âœ… Validation of original problematic query
- âœ… Pattern debugging tools

**Test Results Summary**:
- âœ… Feedback table classifier: 70% confidence on critical queries
- âœ… System vs content feedback distinction: Working correctly
- âœ… Query classification integration: Table guidance appearing in results
- âœ… Original problem query: Now correctly suggests `evaluation` table

### **Phase 2 Impact Assessment** âœ…

**Problem Resolution**:
- âœ… **Root Cause Addressed**: LLM will no longer incorrectly join `rag_user_feedback` with `learning_content`
- âœ… **Table Guidance**: Clear SQL generation guidance for feedback queries
- âœ… **Pattern Coverage**: Comprehensive patterns catch various feedback query formats

**Current Status**:
- âœ… **Classification Enhancement**: Functional and tested
- âœ… **Table Routing**: Working for both content and system feedback
- âœ… **SQL Guidance**: Enhanced prompts with specific table recommendations

**Remaining Considerations**:
- ðŸ”„ Some queries still classified as HYBRID instead of VECTOR (not critical for core functionality)
- ðŸ”„ Could add more patterns for edge cases as they are discovered
- ðŸ”„ Ready to proceed to Phase 3 (Query Validation) when needed

### **Phase 3: Enhanced Error Detection & Recovery**

#### **3.1 Query Validation Layer**
**File**: `src/rag/core/text_to_sql/query_validator.py` (new)

**Objective**: Detect and correct common query logic errors

```python
class QueryLogicValidator:
    """
    Validates SQL queries for logical correctness and suggests corrections.
    """
    
    def __init__(self):
        self.problematic_patterns = [
            {
                "pattern": r"rag_user_feedback.*JOIN.*learning_content",
                "issue": "Incorrect join: rag_user_feedback is for system feedback, not content feedback",
                "suggestion": "Use evaluation table for learning content feedback"
            },
            {
                "pattern": r"LIKE.*\|\|.*name.*\|\|",
                "issue": "Semantic mismatch: joining query text with content names",
                "suggestion": "Use proper foreign key relationships"
            }
        ]
    
    async def validate_and_correct(self, sql_query: str, original_question: str) -> Dict[str, Any]:
        """
        Validate SQL query and suggest corrections if needed.
        """
        issues = []
        for pattern_info in self.problematic_patterns:
            if re.search(pattern_info["pattern"], sql_query, re.IGNORECASE):
                issues.append(pattern_info)
        
        if issues:
            # Generate corrected query
            corrected_query = await self._generate_corrected_query(sql_query, original_question, issues)
            return {
                "valid": False,
                "issues": issues,
                "corrected_query": corrected_query,
                "should_retry": True
            }
        
        return {"valid": True, "issues": [], "should_retry": False}
```

#### **3.2 Integration with SQL Tool**
**File**: `src/rag/core/text_to_sql/sql_tool.py`

**Enhancement**: Add validation step before query execution

```python
async def execute_query_with_validation(self, query: str, original_question: str) -> SQLResult:
    """
    Execute SQL query with logical validation and auto-correction.
    """
    # Validate query logic
    validation_result = await self.query_validator.validate_and_correct(query, original_question)
    
    if not validation_result["valid"] and validation_result["should_retry"]:
        logger.warning(f"Query validation failed: {validation_result['issues']}")
        logger.info("Attempting query correction...")
        
        # Try corrected query
        corrected_query = validation_result["corrected_query"]
        return await self._execute_sql_query(corrected_query)
    
    return await self._execute_sql_query(query)
```

### **Phase 4: Enhanced Testing & Monitoring**

#### **4.1 Query Logic Test Suite**
**File**: `src/rag/tests/test_query_logic_validation.py` (new)

```python
class TestQueryLogicValidation:
    """
    Test suite for query logic validation and correction.
    """
    
    @pytest.mark.asyncio
    async def test_learning_content_feedback_queries(self):
        """Test that learning content feedback queries use correct tables."""
        test_cases = [
            "What feedback did users give about Live Learning courses?",
            "How do users feel about virtual training sessions?",
            "What are the main issues with online courses?",
            "Show me user comments about course quality"
        ]
        
        for question in test_cases:
            result = await self.sql_tool.process_question(question)
            
            # Should use evaluation table, not rag_user_feedback
            assert "evaluation" in result.query.lower()
            assert "rag_user_feedback" not in result.query.lower()
            assert result.row_count > 0  # Should return actual data
    
    @pytest.mark.asyncio
    async def test_rag_system_feedback_queries(self):
        """Test that RAG system feedback queries use correct tables."""
        test_cases = [
            "How do users rate the RAG system responses?",
            "What feedback do users give about system performance?",
            "Show me ratings for AI-generated answers"
        ]
        
        for question in test_cases:
            result = await self.sql_tool.process_question(question)
            
            # Should use rag_user_feedback table
            assert "rag_user_feedback" in result.query.lower()
            assert result.row_count >= 0  # May be empty, that's ok
```

#### **4.2 Real-time Query Monitoring**
**File**: `src/rag/utils/query_monitor.py` (new)

```python
class QueryLogicMonitor:
    """
    Monitors query generation for logic issues and tracks corrections.
    """
    
    async def log_query_analysis(self, question: str, generated_sql: str, result_count: int):
        """
        Log query generation analysis for continuous improvement.
        """
        analysis = {
            "timestamp": datetime.utcnow(),
            "question": question,
            "generated_sql": generated_sql,
            "result_count": result_count,
            "logic_issues": await self._detect_logic_issues(generated_sql),
            "table_usage": self._extract_table_usage(generated_sql)
        }
        
        # Alert on empty results for feedback queries
        if result_count == 0 and "feedback" in question.lower():
            await self._alert_empty_feedback_query(analysis)
```

---

## **Implementation Timeline**

### **Week 1: Core Fixes**
- [ ] Enhanced schema descriptions in SchemaManager
- [ ] Query validation layer implementation
- [ ] Updated SQL generation prompts

### **Week 2: Testing & Validation**
- [ ] Comprehensive test suite for query logic
- [ ] Black-box testing with corrected system
- [ ] Performance impact assessment

### **Week 3: Monitoring & Refinement**
- [ ] Real-time query monitoring implementation
- [ ] Feedback collection on query corrections
- [ ] Documentation updates

---

## **Expected Outcomes**

### **Immediate Benefits**
- âœ… Correct SQL generation for learning content feedback queries
- âœ… Proper data retrieval with meaningful results
- âœ… Improved answer synthesis quality

### **Long-term Benefits**
- âœ… Reduced query logic errors across all query types
- âœ… Better understanding of data model relationships
- âœ… Continuous improvement through monitoring and validation

### **Success Metrics**
- **Query Accuracy**: >95% of feedback queries use correct tables
- **Result Quality**: >90% of feedback queries return meaningful data
- **User Satisfaction**: Improved ratings for content feedback responses

---

## **Risk Assessment**

### **Low Risk**
- Enhanced schema descriptions (no breaking changes)
- Query validation layer (additive feature)

### **Medium Risk**
- Modified SQL generation prompts (requires thorough testing)
- Integration with existing query processing pipeline

### **Mitigation Strategies**
- Comprehensive test suite before deployment
- Gradual rollout with monitoring
- Fallback to original query generation if validation fails

---

## **Next Steps**

1. **Implement Phase 1** (Enhanced Schema Context) - Highest priority
2. **Test with original failing query** to validate fix
3. **Expand test cases** for comprehensive coverage
4. **Monitor query generation patterns** for other potential issues

This implementation plan addresses the root cause while building a robust framework for preventing similar issues in the future.